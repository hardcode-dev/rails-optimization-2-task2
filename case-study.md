# Case-study оптимизации

## Актуальная проблема
В нашем проекте возникла серьёзная проблема.

Необходимо было обработать файл с данными, чуть больше ста мегабайт.

У нас уже была программа на `ruby`, которая умела делать нужную обработку.

Она успешно работала на файлах размером пару мегабайт, но для большого файла она работала слишком долго, и не было понятно, закончит ли она вообще работу за какое-то разумное время.

Я решил исправить эту проблему, оптимизировав эту программу.

## Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы я придумал использовать такую метрику: потребление памяти в мегабайтах при обработке файла в 10_000 строк. Позднее количество строк было увеличено

## Гарантия корректности работы оптимизированной программы
Программа поставлялась с тестом. Выполнение этого теста в фидбек-лупе позволяет не допустить изменения логики программы при оптимизации.

## Feedback-Loop
Для того, чтобы иметь возможность быстро проверять гипотезы я выстроил эффективный `feedback-loop`, который позволил мне получать обратную связь по эффективности сделанных изменений за ~ 5 секунд
Для этого я модифицировал rake-файл из моего первого домашнего задания

Вот как я построил `feedback_loop`:
Для начала я взял файл размером 10_000 строк
- Выполняется rake который прогоняет тест корректности работы, тест по затратам памяти и производительности, профилирование. Тест производительности нужен для защиты от неэффективной оптимизации, на случай если получится что использование памяти уменьшилось путем увеличения нагрузки на CPU
- По результатам профилирования ищется главная точка роста
- Вносятся правки в код, прогоняется рэйк-таска -- если тесты не упали и точка роста поменялась то апдейчу тесты и ищу новую точку роста

## Вникаем в детали системы, чтобы найти главные точки роста
Для того, чтобы найти "точки роста" для оптимизации я воспользовался memory_profiler и ruby-prof в режимах flat и callstack

Вот какие проблемы удалось найти и решить

### Ваша находка №1
- Согласно плану работы сначала было решено перевести программу на потоковый подход
- Теперь данные не накапливаются а сразу записываются в файл с результатом
- 104Мб -> 28Мб. Я решил сравнить разницу для файла в 100_000 строк, получилось 249Мб -> 37Мб. В идеале на оптимизированной программе количество затрачиваемой памяти не должно особо меняться в зависимости от размера файла, так что явное еще есть проблемы
- memory_profiler показывал основными точками роста парсинг и накопление сессий, больше они не являются точками роста

### Ваша находка №2
- Я ориентировался на memory_profiler чтобы обратить внимания на места которые могут увеличивать использование памяти в зависимости от роста файла. Одно из таких мест -- сбор массива всех браузеров
- Вместо того чтобы собирать массив браузеров и затем применять метод .uniq, будем класть браузеры в Set
- 37Мб -> 29Мб. Проверим на файле data_large.txt -- 355Мб -> 29Мб. Судя по всему в первом шаге были настолько существенные изменения что оставалась только одна эта проблема, в то же время любопытно как сильно может влияеть такая мелочь на расход памяти
- Несмотря на то что наш бюджет был 70Мб и в него удалось уложиться с запасом, в учебных целях решил посмотреть какие еще места можно оптимизировать

### Ваша находка №X
- Посмотрел по memory_profiler какие еще есть подозрительные места. Главной точкой роста оставался String#split но тут не удалось особо оптимизировать.
- Убрал лишние присваивания, использовал bang-методы там где возможно
- 29Мб -> 28Мб, разницы почти нет
- Почти не изменился

## Результаты
В результате проделанной оптимизации наконец удалось обработать файл с данными.
Удалось улучшить метрику системы с 104 мб для 10_000 строк на 28 мб для любого количества строк и уложиться в заданный бюджет.

По сравнению с результатом выполнения первого домашнего задания скорость работы программы улучилась почти в три раза -- с 23 секунд до 8.5

valgrind massif visualizer показывает что пиковое потребление памяти 40Мб

## Защита от регрессии производительности
Для защиты от потери достигнутого прогресса при дальнейших изменениях программы были написаны автотесты производительности и аллокации памяти
