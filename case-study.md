# Case-study оптимизации

## Актуальная проблема
В нашем проекте возникла серьёзная проблема.

Необходимо было обработать файл с данными, чуть больше ста мегабайт.

У нас уже была программа на `ruby`, которая умела делать нужную обработку.

Она успешно работала на файлах размером пару мегабайт, 
но для большого файла она занимала много оперативной памяти, до 2.5 Гб.

Я решил исправить эту проблему, оптимизировав эту программу.

## Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект 
на быстродействие программы я придумал использовать такую метрику: 
-   количество используемой оперативной памяти по окончанию работы программы

Бюджет: 70 Мб

## Гарантия корректности работы оптимизированной программы
Программа поставлялась с тестом. 
Выполнение этого теста в фидбек-лупе позволяет не допустить изменения логики программы 
при оптимизации.

## Feedback-Loop
Для того, чтобы иметь возможность быстро проверять 
гипотезы я выстроил эффективный `feedback-loop`, 
который позволил мне получать обратную связь по эффективности сделанных 
изменений за 3-5 секунд.

Вот как я построил `feedback_loop`: 
для получения feedback необходимо запустить ruby assimptotics.rb. Программа возвращает
и скорость выполнения на части данных и накапливаемый размер оперативной памяти. Не хотелось бы
оптимизируя память снижать скорость выполнения.
Внутри программы можно регулировать размер входного файла по размеру и по количеству.

## Вникаем в детали системы, чтобы найти главные точки роста
Для того, чтобы найти "точки роста" для оптимизации я 
воспользовался:

    rubocop
    rubocop-performance

Вот какие проблемы удалось найти и решить

### Ваша находка №1
- первичные показатели программы:

      1000: 0 sec; MEMORY USAGE: 31 MB
      10000: 1 sec; MEMORY USAGE: 103 MB
      20000: 6 sec; MEMORY USAGE: 153 MB

- после применения rubocop особых изменений нет 

      1000: 0 sec; MEMORY USAGE: 31 MB
      10000: 1 sec; MEMORY USAGE: 103 MB
      20000: 6 sec; MEMORY USAGE: 153 MB

### Ваша находка №2
- Поменял программу на скрипт из 1го урока. На полном файле потребление памяти порядка
  2.5 Гб.

      300000: 1 sec; MEMORY USAGE: 333 MB

- Запустил memory-profiler (/1-ruby-memory-profiler). Получил следующие результаты

      130.16 MB  /home/filonov/optim/rails-optimization-task2/task-2.rb:56
      42.65 MB  /home/filonov/optim/rails-optimization-task2/task-2.rb:35

  Основную память занимает работа строчки со split. Поменял на split с блоком, пишут, 
  что он и работает в 2 раза быстрее в каких-то случаях. Массив значений строки
  проинициализировал 1 раз, заполняю в блоке. 
  За счет этого кол-во объектов массивов уменьшилось на 300 тыс.
  
    
- Потребление памяти снизилось на 10%. Не панацея, но пусть будет. 

      300000: 1 sec; MEMORY USAGE: 300 MB


### Ваша находка №3
- Запустил ruby-prof. Режим flat показал

      %self      total      self      wait     child     calls  name                           location
      45.44  1753884.000 1753884.000     0.000     0.000   300000   String#split                   
      13.16  507768.000 507768.000     0.000     0.000   507768   String#upcase                  
      13.14  1505532.000 507238.000     0.000 998294.000    46119  *Array#each

- Собственно, без изменений, string#split занимает 45% памяти. Также посмотрел отчеты
  graph и callstack. Второе место за 

      28.85% (28.85%) Object#collect_stats_from_users [1 calls, 1 total]
  
  Пока не придумал как избавиться от string#split совсем. Решил согласно заданию переделать программу 
  на более "потоковую" обработку.
  
  1) Первое решение - собирать UserObjects в главном цикле по мере чтения файла, чтобы избавиться от 
  отдельных массивов по пользователям и сессиям.
  
  2) Переработал класс User. Включил в него информацию, которая необходима
  для отчета в разрезе пользователя: браузеры, макс. сессия, сумма времени сессий, 
  использование браузеров и т.д.

  3) Переработал подсчет уникальных браузеров в главном цикле чтения файла. Туда же включил
  количество сессий. Убрал лишние циклы по юзерам/сессиям при подсчете браузеров.
  
  4) Доработал класс User, раз в нем уже есть вся необходимая информация в разрезе юзера, 
  убрал внутренний массив sessions. Это главная доработка данного этапа. Также убрал лишние
  атрибуты юзера и сессии. Также в классе вместо атрибутов оставил составной ключ, который используется в отчете.
     

- Метрика изменилась в лучшую сторону кардинально, в два раза. Мало того и время работы
 стало 14 сек вместо 21 сек.

      300_000: 1 sec; MEMORY USAGE: 131 MB
      3000_000: 16 sec; MEMORY USAGE: 1033 MB

- отчёт профилировщика

      %self      total      self      wait     child     calls  name                           location
      49.97  1753884.000 1753884.000     0.000     0.000   300000   String#split                   
      9.86  3138215.000 346130.000     0.000 2792085.000        1   <Class::IO>#foreach            
      7.23  253886.000 253886.000     0.000     0.000   253886   String#upcase                  
      7.23  507768.000 253884.000     0.000 253884.000   253884   Object#parse_session
      6.57  371087.000 230550.000     0.000 140537.000    92245  *Array#each                     
      3.94  221204.000 138349.000     0.000 82855.000    46116   User#initialize

### Ваша находка №3
- Запустил ruby-prof анализатором kcachegrind. И что же там видим. О боже, снова String#split.
  Здесь меня "осенило", что String#split сам по себе не виноват, если обрезать сохранение результатов, 
  то программа показывает минимальное потребление памяти. Причем я это делал вначале, но прошло мимо меня. 
  Значит надо до конца добивать чтение строки файла, формирование статистики пользователя, что уже сделал, и запись
  результата в файл. Проделал это в несколько итераций. Программа начала показывать 28Мб на любом входном размере файла.
  При этом также сократилось время работы до 13 секунд. Процессор i5 10400.


     3000000: 13 sec; MEMORY USAGE: 28 MB  

  Местами оптимизировал лишнего, слишком разошлась рука, пришлось немного откатить обратно.
  Что не понравилось - создавать json из кусочков строк, получился не руби стайл.

### Ваша находка №4
  Запустил valgrind. Ровный график, 41Мб.

## Результаты
В результате проделанной оптимизации наконец удалось обработать файл с данными.
Удалось улучшить метрику системы с 2.5 Гб по окончанию работы программы
до 28 Мб во время работы всей программы и уложиться в заданный бюджет.

## Защита от регрессии производительности
Для защиты от потери достигнутого прогресса при дальнейших изменениях 
программы добавил тест на отсутствия превышения памяти выше 50Мб

