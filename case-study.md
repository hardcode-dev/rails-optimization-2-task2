# Case-study оптимизации

## Актуальная проблема
В нашем проекте возникла серьёзная проблема.

Необходимо было обработать файл с данными, чуть больше ста мегабайт.

У нас уже была программа на `ruby`, которая умела делать нужную обработку.

Она успешно работала на файлах размером пару мегабайт, но для большого файла она работала слишком долго, и не было понятно, 
закончит ли она вообще работу за какое-то разумное время.

Я решил исправить эту проблему, оптимизировав эту программу.

## Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы я придумал использовать 
такую метрику: *тут ваша метрика*
использовал:
ruby_prof_reports/flat 
ruby_prof_reports/callstack 

## Гарантия корректности работы оптимизированной программы
Программа поставлялась с тестом. Выполнение этого теста в фидбек-лупе позволяет не допустить изменения логики программы 
при оптимизации.

## Feedback-Loop
Для того, чтобы иметь возможность быстро проверять гипотезы я выстроил эффективный `feedback-loop`, который позволил мне 
получать обратную связь по эффективности сделанных изменений за  10 - 20 сек увеличивал кол-во строк.


## Вникаем в детали системы, чтобы найти главные точки роста
Взял уже оптимизированную программу по процессору. И хочу оптимизировать по памяти.

Для того, чтобы найти "точки роста" для оптимизации я воспользовался *инструментами, которыми вы воспользовались*
ruby_prof_reports/callstack 

Вот какие проблемы удалось найти и решить

### Ваша находка №1
- какой отчёт показал главную точку роста
    MemoryProfiler 
    Total allocated: 20.61 MB (320832 objects)
    
    ruby-prof- flat
    Total: 326855.000000

- как вы решили её оптимизировать
    Применить  frozen string

- как изменилась метрика
    Total allocated: 16.78 MB (225076 objects)
    
    
    ruby-prof- flat
    Total: 231096.000000


- как изменился отчёт профилировщика
выделенных объектов по стрингам уменьшилось с 282040  String до 186284  String

### Ваша находка №2
    переписал программу на потоковую запись отчета в переменную 
    взял объем данных 300к строк
    frozen string - в данном случае не работает.
    
    MEMORY USAGE: 1114 MB
    Нужно переписать в потоковое чтение файла, а потом возможно в потоковую запись.
    
- какой отчёт показал главную точку роста
    Сделал построчное чтение. эффекта не достиг желаемого.
    но когда закоментировал MemoryProfiler памяти использовалось в 2 раза меньше.
    MEMORY USAGE: 497 MB на 300к строк.

- как вы решили её оптимизировать
    убрал отмену GC - и тут стало гараздо лучше!
- как изменилась метрика
MEMORY USAGE: 343 MB - на большом файле.

- как изменился отчёт профилировщика

### Ваша находка №X
MEMORY USAGE: 343 MB
попробую включить опять frozen string, 

- какой отчёт показал главную точку роста
0.91% (0.91%) FalseClass#to_s [57684 calls, 57685 total]
0.55% (0.55%) TrueClass#to_s [34546 calls, 34547 total]
- как вы решили её оптимизировать
чтобы убрать boolean to string сразу создал эти переменные, там где просто нужны флаги.
- как изменилась метрика
эти задержки ушли.
- как изменился отчёт профилировщика

## Результаты
В результате проделанной оптимизации наконец удалось обработать файл с данными.
Удалось улучшить метрику системы с *6 гигабайт, до до 350мб (250мб) в пике* и почти уложиться в заданный бюджет.

*Какими ещё результами можете поделиться*
Удалось проверить файл через valgrind-massif, потому что стал мало памяти потреблять.

## Защита от регрессии производительности
Для защиты от потери достигнутого прогресса при дальнейших изменениях программы *о performance-тестах, которые вы написали*



https://prnt.sc/urxop4

https://prnt.sc/urzf61 - loop