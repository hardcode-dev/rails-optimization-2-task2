# Case-study оптимизации

## Актуальная проблема
В нашем проекте возникла серьёзная проблема.

Необходимо было обработать файл с данными, чуть больше ста мегабайт.

У нас уже была программа на `ruby`, которая умела делать нужную обработку.

Она успешно работала на файлах размером пару мегабайт, но для большого файла она работала слишком долго, и не было понятно, закончит ли она вообще работу за какое-то разумное время.

Я решил исправить эту проблему, оптимизировав эту программу.

## Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы я придумал использовать такую метрику: количество потребляемой памяти.

## Гарантия корректности работы оптимизированной программы
Программа поставлялась с тестом. Выполнение этого теста в фидбек-лупе позволяет не допустить изменения логики программы при оптимизации.

## Feedback-Loop
Для того, чтобы иметь возможность быстро проверять гипотезы я выстроил эффективный `feedback-loop`, который позволил мне получать обратную связь по эффективности сделанных изменений за 1 минуту.

Вот как я построил `feedback_loop`:
- Запуск программы с профилировщиком
- Определение точки роста
- Внесение изменений
- Запуск программы для определения влияния изменений на метрику

## Вникаем в детали системы, чтобы найти главные точки роста
Для того, чтобы найти "точки роста" для оптимизации я воспользовался memory_profiler и ruby-prof.

Вот какие проблемы удалось найти и решить

### Ваша находка №1

Я взял за основу проведенную в первом задании оптимизацию, поэтому мог сразу использовать полный файл data_large для тестирования потребления памяти.
Исходно программа потребляла 3888 мегабайт.

memory-profiler показал высокое использование памяти при чтении всего файла.
Я переделал чтение файла на потоковое (`File.foreach`), это снизило потребление до 3300 Мб.

### Ваша находка №2
memory-profiler показал высокое использование памяти при мемоизации данных о пользователях и сессиях
Я переделал обработку строк на потоковый режим (пишем сразу в файл, когда собрали всю информацию по юзеру). Использовал гем oj (инструмент stream writer).
Потребление памяти снизилось до 32 Мб.

## Результаты
В результате проделанной оптимизации наконец удалось обработать файл с данными.
Удалось улучшить метрику системы с 3888 Мб до 32 Мб и уложиться в заданный бюджет.
Возникли проблемы с развертыванием проекта в докере под M1 (не собирались нативные расширения), поэтому valgrind massif visualier воспользоваться не удалось.
Чтобы это частично компенсировать, я добавил периодический вывод в консоль потребляемой памяти, и в ходе обработки файла видно, что она не выходит за допустимые пределы.

Скорость выполнения не ухудшилась в сравнении с оптимизированным первым заданием.

## Защита от регрессии производительности
Для защиты от потери достигнутого прогресса при дальнейших изменениях программы я добавил тест RSpec на потребляемую память.
