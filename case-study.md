# Case-study оптимизации

## Актуальная проблема
В нашем проекте возникла серьёзная проблема.

Необходимо было обработать файл с данными, чуть больше ста мегабайт.

У нас уже была программа на `ruby`, которая умела делать нужную обработку.

Она успешно работала на файлах размером пару мегабайт, но для большого файла она работала слишком долго, и не было понятно, закончит ли она вообще работу за какое-то разумное время.

Я решил исправить эту проблему, оптимизировав эту программу.

## Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы я придумал использовать такую метрику: количество созданных объектов по данным ObjectSpace, поле :TOTAL

## Гарантия корректности работы оптимизированной программы
Программа поставлялась с тестом. Выполнение этого теста в фидбек-лупе позволяет не допустить изменения логики программы при оптимизации.

## Feedback-Loop
Для того, чтобы иметь возможность быстро проверять гипотезы я выстроил эффективный `feedback-loop`, который позволил мне получать обратную связь по эффективности сделанных изменений за ~10 секунд на данных 50к строк исходного файла

Вот как я построил `feedback_loop`: 
- внесение изменений в код
– запуск тестов 
– запуск программы и формирование отчета
– анализ отчетов и поиск точек роста
– к шагу 11

## Вникаем в детали системы, чтобы найти главные точки роста
Для того, чтобы найти "точки роста" для оптимизации я воспользовался *инструментами, которыми вы воспользовались*

Вот какие проблемы удалось найти и решить

### Ваша находка №0
На нулевом шаге перевел программу на потоковый стиль обработки данных
Это сходу дало существенный прирост метрики
ObjectSpace.count_objects[:TOTAL] => 2_372_250 -> 2_086_508 

### Ваша находка №1
Ruby prof, graph report указывал на метод add_stats(50% памяти от всего объема программы), а внутри него самыми затратными являлись операции Array#map(SELF=4.09%) и Date.parse(SELF=18.41%)
Я решил взять за Date.parse

Этот метод оказался не нужен, так как данные приходят уже в нужном формате

Метрика ObjectSpace[:TOTAL] улучшилась почти вдвое 2_047_784 -> 1_351_604

add_stats перестал показываться в топе ответа ruby-prof graph

### Ваша находка №2
- Отчет ruby-prof показывал в топе String.split – эта операция забирала 50% ресурсов
Также она находилась в топ-5 проблем по memory_profiler
21.69 MB  /Users/otmosina/work/learn/course/rails-optimization-task2/task-2.rb:65
Решил отпимизировать ее

- Метод вызывался лишний раз в функциях parse_session & parse_user – убрал вызовы оттуда, оставив один

- Метрика ObjectSpace[:TOTAL] улучшилась 1_351_604 -> 1_051_608

- Отчет ruby-prof изменился – String.split ушел из топа

### Ваша находка №3
- Отчет RubyProf(MEMORY mode) показал что в топе вновь оказался метод add_stats
Построенное дерево в qcachegrind показывает, что внутри add_stats топ памяти потребляется в Array.map
Далее спускаясь по дереву видим, что внутри Array.map вызывается upcase и потребляет много памяти
Решил разобраться с upcase
- В add_stats метод upcase вызывает два раза на одних и тех же данных. Вынес вызов этого метода в одно место
- Метрика ObjectSpace[:TOTAL] улучшилась 1_051_608 -> 919_545
- Отчет RubyProf(MEMORY mode) изменился – upcase пропал из дерева отчета

### Ваша находка №4
- Отчет RubyProf(MEMORY mode) показал что в топе вновь оказался метод add_stats 25.26% памяти
Построенное дерево в qcachegrind показывает, что внутри add_stats топ памяти потребляется в:
 Array.map(12.45%) -> String.strip(4.72%)

- Решил убрать String.strip из метода, а также убрать дублирующиеся вызовы map
- String::strip Метрика ObjectSpace[:TOTAL] улучшилась 919_545 -> 913_426
Стал создавать массивы с браузерами и временем перед формированием json, чтобы не дублировать одинаковые массивы по которым делаются операции min||max и выбираются наборы с нужными бразусерами. Метрика ObjectSpace[:TOTAL] улучшилась 913_426 -> 866_962 


- String::strip Отчет RubyProf(MEMORY mode) изменился add_stats 25.26% -> 20.54% | Array.map 12.45% -> 7.73%
Array.map Отчет RubyProf(MEMORY mode) изменился add_stats 20.54% -> 16.22% | Array.map 7.73% -> 2.72%


### Ваша находка №5
- Отчет RubyProf(MEMORY mode) показал что в топе вновь оказался метод add_stats ~16% памяти
После предыдущей находки подсветилась проблема String::+(1.8%)
- Заменил + на << чтобы не создавать лишних String объектов
- ObjectSpace[:TOTAL] улучшилась 866_962 ->  851_883
- Проблема String+ ушла из отчета qcachegrind, add_stats 16.22% -> 14.67% 


### Ваша находка №X
- какой отчёт показал главную точку роста
- как вы решили её оптимизировать
- как изменилась метрика
- как изменился отчёт профилировщика


## Результаты
В результате проделанной оптимизации наконец удалось обработать файл с данными.
Удалось улучшить метрику системы с *того, что у вас было в начале, до того, что получилось в конце* и уложиться в заданный бюджет.

*Какими ещё результами можете поделиться*

## Защита от регрессии производительности
Для защиты от потери достигнутого прогресса при дальнейших изменениях программы *о performance-тестах, которые вы написали*
