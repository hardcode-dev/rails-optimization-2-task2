
## Выделение памяти при формировании списка сессий

### Инструменты

memory_profiler

### Проблема

При первоначальном проходе по исходному файлу больше всего памяти выделялось на создание массивов сессий
при добавлении в него нового элемента.

`sessions = sessions + [parse_session(line)] if cols[0] == 'session'`

### Решение

Исправлено добавлением элементов в существующий массив вместо создания новых.

`sessions << parse_session(line) if cols[0] == 'session'`

### Результаты

|         memory_profiler        |       Было      |      Стало      |     Разница     |    Разница %    |
|--------------------------------|-----------------|-----------------|-----------------|-----------------|
| total_allocated_memsize        |       288800541 |       104953685 |      -183846856 | -64%            |
| total_allocated                |          374585 |          361045 |          -13540 | -4%             |
| total_retained_memsize         |            4201 |            4201 |               0 | 0%              |
| total_retained                 |               9 |               9 |               0 | 0%              |


|            benchmark           |       Было      |      Стало      |     Разница     |    Разница %    |
|--------------------------------|-----------------|-----------------|-----------------|-----------------|
| 1                              | 21ms            | 21ms            |               0 | 0%              |
| 2                              | 57ms            | 56ms            |              -1 | -2%             |
| 4                              | 181ms           | 176ms           |              -5 | -3%             |
| 8                              | 626ms           | 612ms           |             -14 | -3%             |

## Выделение памяти при формировании списка сессий

### Инструменты

memory_profiler

### Проблема

При первоначальном проходе по исходному файлу больше всего памяти выделялось на создание массивов сессий
при добавлении в него нового элемента.

`user_sessions = sessions.select { |session| session['user_id'] == user['id'] }`

### Решение

Группировка сессий по пользователям объективно необходима для дальнейшего рассчёта
детельной статистики пользователя.

Альтернативным решением мог бы быть отказ от данных сессий и рассчёт
статистики на лету, но целесообразность такого решения маловероятна,
поэтому пока игнорируем проблему.

Кроме того проблема должна отпасть сама собой при переходе на
поточные чтение и запись (в этом случае сборщик мусора будет удалять
из памяти все обработанные объекты).

Можно было бы уже переходить к реализации данного алгоритма,
так как очевидно что это даст максимальный эффект
но сначала хочется поправить проблемные места более точечно,
чтобы сохранить уверенность в полезности каждого изменения.


## Выделение памяти на ненужные массивы при формировании списка пользователей

### Инструменты

memory_profiler

### Проблема

Так же как и с сессиями.
При первоначальном проходе по исходному файлу много памяти выделялось на создание массивов пользователей
при добавлении в него нового элемента.

`users = users + [parse_user(line)] if cols[0] == 'user'`

### Решение

Исправлено добавлением элементов в существующий массив вместо создания новых.

`users << parse_user(line) if cols[0] == 'user'`

### Результаты

|         memory_profiler        |       Было      |      Стало      |     Разница     |    Разница %    |
|--------------------------------|-----------------|-----------------|-----------------|-----------------|
| total_allocated_memsize        |       104953685 |        98804213 |        -6149472 | -6%             |
| total_allocated                |          361045 |          358585 |           -2460 | -1%             |
| total_retained_memsize         |            4201 |            4201 |               0 | 0%              |
| total_retained                 |               9 |               9 |               0 | 0%              |


|            benchmark           |       Было      |      Стало      |     Разница     |    Разница %    |
|--------------------------------|-----------------|-----------------|-----------------|-----------------|
| 1                              | 21ms            | 21ms            |               0 | 0%              |
| 2                              | 56ms            | 56ms            |               0 | 0%              |
| 4                              | 176ms           | 175ms           |              -1 | -1%             |
| 8                              | 612ms           | 608ms           |              -4 | -1%             |

## Выделение памяти при сортировке дат 

### Инструменты

memory_profiler

### Проблема

Множество объектов создаётся в процессе парсинга даты для последующей сортировки.

`s['date']}.map {|d| Date.parse(d)}.sort.reverse.map { |d| d.iso8601 }`

### Решение

В данном случае достаточно просто отсортировать строки, поэтому просто убрал лишние преобразования.

`s['date']}.sort.reverse`

### Результаты

|         memory_profiler        |       Было      |      Стало      |     Разница     |    Разница %    |
|--------------------------------|-----------------|-----------------|-----------------|-----------------|
| total_allocated_memsize        |        98804213 |        92960124 |        -5844089 | -6%             |
| total_allocated                |          358585 |          274871 |          -83714 | -24%            |
| total_retained_memsize         |            4201 |              40 |           -4161 | -100%           |
| total_retained                 |               9 |               1 |              -8 | -89%            |


|            benchmark           |       Было      |      Стало      |     Разница     |    Разница %    |
|--------------------------------|-----------------|-----------------|-----------------|-----------------|
| 1                              | 21ms            | 20ms            |              -1 | -5%             |
| 2                              | 56ms            | 55ms            |              -1 | -2%             |
| 4                              | 175ms           | 179ms           |               4 | 2%              |
| 8                              | 608ms           | 633ms           |              25 | 4%              |

## Выделение памяти на ненужные массивы при формировании списка объектов пользователей

### Инструменты

memory_profiler

### Проблема

Так же как и с сессиями и атрибутами пользователей.
При первоначальном проходе много памяти выделялось на создание лишних массивов 
при добавлении нового элемента.

`users_objects = users_objects + [user_object]`

### Решение

Исправлено добавлением элементов в существующий массив вместо создания новых.

`users_objects << user_object`

### Результаты

|         memory_profiler        |       Было      |      Стало      |     Разница     |    Разница %    |
|--------------------------------|-----------------|-----------------|-----------------|-----------------|
| total_allocated_memsize        |        92960124 |        86810652 |        -6149472 | -7%             |
| total_allocated                |          274871 |          272411 |           -2460 | -1%             |
| total_retained_memsize         |              40 |              40 |               0 | 0%              |
| total_retained                 |               1 |               1 |               0 | 0%              |


|            benchmark           |       Было      |      Стало      |     Разница     |    Разница %    |
|--------------------------------|-----------------|-----------------|-----------------|-----------------|
| 1                              | 20ms            | 19ms            |              -1 | -5%             |
| 2                              | 55ms            | 52ms            |              -3 | -6%             |
| 4                              | 179ms           | 165ms           |             -14 | -8%             |
| 8                              | 633ms           | 584ms           |             -49 | -8%             |

## Повторное разделение строки по запятым 

### Инструменты

memory_profiler

### Проблема

При первоначальной обработке строк 2 раза происходит разбивка по запятым

```ruby
cols = line.split(',')
users << parse_user(line) if cols[0] == 'user'
sessions << parse_session(line) if cols[0] == 'session'

# ...
def parse_user(line)
  fields = line.split(',')
  # ...
end

def parse_session(line)
  fields = line.split(',')
  # ...
end
```

### Решение

Передаю строку данные уже в виде подготовленного массива.

```ruby
cols = line.split(',')
users << parse_user(cols) if cols[0] == 'user'
sessions << parse_session(cols) if cols[0] == 'session'

# ...
def parse_user(fields)
  # ...
end

def parse_session(fields)
  # ...
end
```

### Результаты

|         memory_profiler        |       Было      |      Стало      |     Разница     |    Разница %    |
|--------------------------------|-----------------|-----------------|-----------------|-----------------|
| total_allocated_memsize        |        86810652 |        82953492 |        -3857160 | -5%             |
| total_allocated                |          272411 |          209641 |          -62770 | -24%            |
| total_retained_memsize         |              40 |              40 |               0 | 0%              |
| total_retained                 |               1 |               1 |               0 | 0%              |


|            benchmark           |       Было      |      Стало      |     Разница     |    Разница %    |
|--------------------------------|-----------------|-----------------|-----------------|-----------------|
| 1                              | 19ms            | 18ms            |              -1 | -6%             |
| 2                              | 52ms            | 50ms            |              -2 | -4%             |
| 4                              | 165ms           | 161ms           |              -4 | -3%             |
| 8                              | 584ms           | 568ms           |             -16 | -3%             |

## Разделение строк на массив по запятым

### Инструменты

memory_profiler

### Проблема

При обработке оригинального файла объективно необходимо разделять
строку по запятым для выделения отдельных атрибутов.

### Решение

Игнорируем. Проблема должна отпасть сама собой при переходе на
поточные чтение и запись (в этом случае сборщик мусора будет удалять
из памяти все обработанные объекты).

## Выделение памяти на одинаковые строки

### Инструменты

memory_profiler

### Проблема

Создание одинаковых строк в цикле приводит в выделению памяти.

### Решение

Включил frozen_string_literal

### Результаты

|         memory_profiler        |       Было      |      Стало      |     Разница     |    Разница %    |
|--------------------------------|-----------------|-----------------|-----------------|-----------------|
| total_allocated_memsize        |      1127601402 |      1121799962 |        -5801440 | -1%             |
| total_allocated                |          835877 |          690842 |         -145035 | -18%            |
| total_retained_memsize         |              40 |              40 |               0 | 0%              |
| total_retained                 |               1 |               1 |               0 | 0%              |


|            benchmark           |       Было      |      Стало      |     Разница     |    Разница %    |
|--------------------------------|-----------------|-----------------|-----------------|-----------------|
| 1                              | 19ms            | 20ms            |               1 | 5%              |
| 2                              | 50ms            | 53ms            |               3 | 6%              |
| 4                              | 158ms           | 172ms           |              14 | 8%              |
| 8                              | 562ms           | 628ms           |              66 | 11%             |
| 16                             | 2149ms          | 2367ms          |             218 | 10%             |
| 32                             | 9410ms          | 9873ms          |             463 | 4%              |

## Выделение памяти под новые хэши при сборе статистики пользователей

### Инструменты

memory_profiler

### Проблема

При объединении статистики пользователей выделяется память под лишний хэш.

`report['usersStats'][user_key] = report['usersStats'][user_key].merge(block.call(user))`

### Решение

Замена `merge` на `merge!`

`report['usersStats'][user_key].merge!(block.call(user))`

### Результаты

|         memory_profiler        |       Было      |      Стало      |     Разница     |    Разница %    |
|--------------------------------|-----------------|-----------------|-----------------|-----------------|
| total_allocated_memsize        |      1121799962 |      1116661618 |        -5138344 | -1%             |
| total_allocated                |          690842 |          656521 |          -34321 | -5%             |
| total_retained_memsize         |              40 |              40 |               0 | 0%              |
| total_retained                 |               1 |               1 |               0 | 0%              |


|            benchmark           |       Было      |      Стало      |     Разница     |    Разница %    |
|--------------------------------|-----------------|-----------------|-----------------|-----------------|
| 1                              | 20ms            | 19ms            |              -1 | -5%             |
| 2                              | 53ms            | 54ms            |               1 | 1%              |
| 4                              | 172ms           | 174ms           |               2 | 1%              |
| 8                              | 628ms           | 637ms           |               9 | 1%              |
| 16                             | 2367ms          | 2404ms          |              37 | 1%              |
| 32                             | 9873ms          | 10054ms         |             181 | 1%              |

## Сложение строк при формировании полного имени пользователя

### Инструменты

memory_profiler

### Проблема

Формирование имени пользователя происходило путём сложения 3 строк

### Решение

Заменил сложение интерполяцией.

### Результаты

|         memory_profiler        |       Было      |      Стало      |     Разница     |    Разница %    |
|--------------------------------|-----------------|-----------------|-----------------|-----------------|
| total_allocated_memsize        |      1116661618 |      1112515434 |        -4146184 | -1%             |
| total_allocated                |          656521 |          553558 |         -102963 | -16%            |
| total_retained_memsize         |              40 |              40 |               0 | 0%              |
| total_retained                 |               1 |               1 |               0 | 0%              |


|            benchmark           |       Было      |      Стало      |     Разница     |    Разница %    |
|--------------------------------|-----------------|-----------------|-----------------|-----------------|
| 1                              | 19ms            | 21ms            |               2 | 10%             |
| 2                              | 54ms            | 57ms            |               3 | 5%              |
| 4                              | 174ms           | 190ms           |              16 | 9%              |
| 8                              | 637ms           | 677ms           |              40 | 6%              |
| 16                             | 2404ms          | 2583ms          |             179 | 7%              |
| 32                             | 10054ms         | 10626ms         |             572 | 5%              |

## Выделение памяти при чтении исходного файла

### Инструменты

memory_profiler

### Проблема

При обработке исходного файла объективно необходимо производить разбивку по строкам и полям.

### Решение

Игнорируем. Проблема должна отпасть сама собой при переходе на
поточные чтение и запись (в этом случае сборщик мусора будет удалять
из памяти все обработанные объекты).
## Неэффективная обработка статистики по использованию браузеров

### Инструменты

memory_profiler

### Проблема

При обработке списка браузеров происходило трёхкратное формирование одних и тех же данных.

```ruby
# Браузеры пользователя через запятую
collect_stats_from_users(report, users_objects) do |user|
  { 'browsers' => user.sessions.map {|s| s['browser']}.map {|b| b.upcase}.sort.join(', ') }
end

# Хоть раз использовал IE?
collect_stats_from_users(report, users_objects) do |user|
  { 'usedIE' => user.sessions.map{|s| s['browser']}.any? { |b| b.upcase =~ /INTERNET EXPLORER/ } }
end

# Всегда использовал только Chrome?
collect_stats_from_users(report, users_objects) do |user|
  { 'alwaysUsedChrome' => user.sessions.map{|s| s['browser']}.all? { |b| b.upcase =~ /CHROME/ } }
end
```

### Решение

Объединил в один цикл.

```ruby
collect_stats_from_users(report, users_objects) do |user|
  browsers = user.sessions.map { |s| s['browser'].upcase }
  {
    # Браузеры пользователя через запятую
    'browsers' => browsers.sort.join(', '),
    # Хоть раз использовал IE?
    'usedIE' => browsers.any? { |b| b =~ /INTERNET EXPLORER/ },
    # Всегда использовал только Chrome?
    'alwaysUsedChrome' => browsers.all? { |b| b =~ /CHROME/ }
  }
end
```

### Результаты

|         memory_profiler        |       Было      |      Стало      |     Разница     |    Разница %    |
|--------------------------------|-----------------|-----------------|-----------------|-----------------|
| total_allocated_memsize        |      1112515434 |      1108181890 |        -4333544 | -1%             |
| total_allocated                |          553558 |          498825 |          -54733 | -10%            |
| total_retained_memsize         |              40 |              40 |               0 | 0%              |
| total_retained                 |               1 |               1 |               0 | 0%              |


|            benchmark           |       Было      |      Стало      |     Разница     |    Разница %    |
|--------------------------------|-----------------|-----------------|-----------------|-----------------|
| 1                              | 21ms            | 19ms            |              -2 | -10%            |
| 2                              | 57ms            | 53ms            |              -4 | -8%             |
| 4                              | 190ms           | 176ms           |             -14 | -8%             |
| 8                              | 677ms           | 626ms           |             -51 | -8%             |
| 16                             | 2583ms          | 2398ms          |            -185 | -8%             |
| 32                             | 10626ms         | 9919ms          |            -707 | -7%             |

## Необходимость перехода на поточную обработку данных

### Инструменты

memory_profiler

### Проблема

Дальнейшие оптимизации не могли привести к значительному эффекту.

### Решение

Требуется переход на поточную обработку исходных данных и запись отчёта,
чтобы память освобождалась в процессе работы скрипта.

## Поточная обработка

Реализация алгоритма позволила не хранить в памяти массивы пользователей и сессий,
а так же позволило избежать выделения сессий конкретного пользователя из общего массива.
Значительная оптимизация по памяти и скорости работы обусловлена именно этими факторами,
так как сборщик мусора при сборе результатов был отключен.

### Результаты

|         memory_profiler        |       Было      |      Стало      |     Разница     |    Разница %    |
|--------------------------------|-----------------|-----------------|-----------------|-----------------|
| total_allocated_memsize        |      1108181890 |        36823893 |     -1071357997 | -97%            |
| total_allocated                |          498825 |          427593 |          -71232 | -15%            |
| total_retained_memsize         |              40 |              40 |               0 | 0%              |
| total_retained                 |               1 |               1 |               0 | 0%              |


|            benchmark           |       Было      |      Стало      |     Разница     |    Разница %    |
|--------------------------------|-----------------|-----------------|-----------------|-----------------|
| 1                              | 19ms            | 7ms             |             -12 | -64%            |
| 2                              | 53ms            | 8ms             |             -45 | -85%            |
| 4                              | 176ms           | 13ms            |            -163 | -93%            |
| 8                              | 626ms           | 23ms            |            -603 | -97%            |
| 16                             | 2398ms          | 48ms            |           -2350 | -98%            |
| 32                             | 9919ms          | 87ms            |           -9832 | -100%           |

Стала возможной обработка больших файлов.
Потребление памяти при обработке файла data_large.txt при включенном сборщике мусора составило 824 MB.

## Поточная запись отчёта

Для поточной записи файла использовал библиотеку oj и её иструмент StreamWriter.
Так же как и с поточным с чтением это позволило по косвенным причинам освободить ещё 10% памяти.

|         memory_profiler        |       Было      |      Стало      |     Разница     |    Разница %    |
|--------------------------------|-----------------|-----------------|-----------------|-----------------|
| total_allocated_memsize        |       294473957 |       267443713 |       -27030244 | -10%            |
| total_allocated                |         3419598 |         3380369 |          -39229 | -2%             |
| total_retained_memsize         |              40 |              40 |               0 | 0%              |
| total_retained                 |               1 |               1 |               0 | 0%              |


|            benchmark           |       Было      |      Стало      |     Разница     |    Разница %    |
|--------------------------------|-----------------|-----------------|-----------------|-----------------|
| 1                              | 8ms             | 8ms             |               0 | 0%              |
| 2                              | 8ms             | 8ms             |               0 | 0%              |
| 4                              | 12ms            | 12ms            |               0 | 0%              |
| 8                              | 19ms            | 26ms            |               7 | 36%             |
| 16                             | 40ms            | 52ms            |              12 | 30%             |
| 32                             | 106ms           | 105ms           |              -1 | -1%             |
| 64                             | 214ms           | 208ms           |              -6 | -3%             |
| 128                            | 443ms           | 412ms           |             -31 | -7%             |
| 256                            | 937ms           | 817ms           |            -120 | -13%            |

Потребление памяти для файла data_large.txt при включенном сборщике мусора на данном этапе составило: 30 MB.

## Защита от регрессии производительности
Для защиты от потери достигнутого прогресса при дальнейших изменениях программы
добавил тест проверяющий общее потребление памяти при обработке большого файла.
Пришлось отказаться от использования для этих целей rspec-benchmark,
так как использование библиотеки блокирует работу сборщика мусора.
В итоге оцениваю вывод команды `ps -o rss= -p #{Process.pid}`.
У данного подхода тоже есть 2 недостатка:
* в вывод включена память выделенная на работу тестового фреймворка;
* при одновременном запуске на его работу могут влиять соседние тесты.

Предполагаю что в рамках текущей задачи такие ограничения допустимы,
в ином случае в тесте пришлось бы использовать файл значительно меньшего объёма.

## Итоги

Удалось снизить потребление памяти до 30MB.
Удалось реализовать мини-фреймворк для удобного итерационного сбора статистики,
который вероятно получится оформить как gem, продолжить развитие и использовать в других задачах.
Появилось понимание того как нужно профилировать потребление памяти и какие подводные камни бывают на пути.

## Massif report

![massif diag](massif.png)
