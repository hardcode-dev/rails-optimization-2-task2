# Case-study оптимизации

## Актуальная проблема
У нас есть программа, которая принимает на вход файл с информацией о сессиях юзеров в своем особом текстовом формате,
и выдает отчет о сессиях в формате json.
Раньше все было хорошо, но теперь возникла необходимость запускать программу на чугунном утюге, поэтому необходимо,
чтобы на протяжении всей работы она **не потребляла больше 70Мб оперативной памяти.**

## Гарантия корректности работы оптимизированной программы
Программа поставлялась с тестом. Выполнение этого теста в фидбек-лупе позволяет не допустить изменения логики программы при оптимизации.

## Feedback-Loop
Для построения эффективного фидбек лупа, нам нужен тест, который будет замерять потребляемую память процесса на протяжении
всей работы.
В rspec-benchmark есть инструменты для замера аллокаций, но не объема памяти. Поэтому мы напишем простой тест используя
возможности ОС.

```ruby
class TestMemoryUsage
  def run
    work_thread = Thread.new do
      work(data_path('data_large.txt'))
    end
    loop do
      sleep(0.3)
      usage = check_memory_usage
      puts "#{usage}Mb"
      if usage > 70
        puts 'Memory usage got higher the limit'
        Thread.exit
      end
      break if !work_thread.status
    end
    work_thread.join
  end

  def check_memory_usage
    (`ps -o rss= -p #{Process.pid}`.to_i / 1024.0).round(2)
  end
end

TestMemoryUsage.new.run
```

Тред для чека памяти будет нести с собой небольшой оверхед по памяти, и мы не сможем гарантировать, что скачков не было
между замерами, но в любом случае, по мере приближения к заданному бюджету мы сможем более точно проверить результат
с помощью valgrind massif visualizer.

## Вникаем в детали системы, чтобы найти главные точки роста
Для того, чтобы найти "точки роста" для оптимизации я воспользовался гемом memory_profiler.
Попытка получить репорт по обработке целевого файла быстро съела 30Гб оперативы и начала свопать диск,
поэтому попробуем профилировать на меньшем объеме данных, но достаточно большом, чтобы не нарушить общую картину
расхода памяти. Для наших целей сгенерим файл со 100_000 юзеров.

### Итерация 1
Хорошие новости - нет retained данных, скрипт написан таким образом, что вся память вычищается GC.
Отчет мемори профайлера показал, что подавляющее большинство памяти уходит на стринги. И большая часть строк
аллоцируется строкой 57: `cols = l.split(',')`. Эту же запятую мы видим в топе аллоцированных строк:
```
359870  "session"
224935  "user"
194936  ","
```
Пока исходя из отчета возможная точка роста - уменьшение количества аллокаций по строкам. Попробуем посмотреть на программу
также с помощью ruby-prof в режиме профилирования памяти.
Ruby-prof также указывает на итерацию `#each_line` и `#split` который вызывается внутри него.
Чтож, попробуем для начала просто сократить количество памяти выделяемой на строки — зафризим в константах
все строковые литералы в скрипте:
```
USER_STR = 'user'.freeze
SESSION_STR = 'session'.freeze
COMMA_STR = ','.freeze
COMMA_SPACE_STR = ', '.freeze
MIN_STR = 'min.'.freeze
SPACE_STR = ' '.freeze
```

Попробуем посмотреть на наш тест и отчеты профайлеров после улучшения.
Похоже не помогло — суммарное потребление памяти программы на файле со 100000 юезров снизилось примерно на 10%.
Наш нехитрый тест на превышение бюджета ожидаемо по прежнему не проходит.
Большая часть аллокаций по прежнему происходит в методе `#split`.

### Итерация 2
Попробуем посмотреть на valgrind massiff.

подумать о том, как наша программа работает.
Основная работа происходит в цикле итераций по файлу. В ходе этих итераций мы накапливаем в памяти
полный список юзеров, сессий этих юзеров и список всех сессий. При этом бОльшую часть отчета занимают данные
со статистикой по каждому юзеру. Очевидно, что существенно сократить память программы
можно, если просто избавиться от необходимости держать эти данные в памяти и переделать сборку отчета в памяти
и результирующем хеше, и писать отчет сразу в result.json



## Результаты
В результате проделанной оптимизации наконец удалось обработать файл с данными.
Удалось улучшить метрику системы с *того, что у вас было в начале, до того, что получилось в конце* и уложиться в заданный бюджет.

*Какими ещё результами можете поделиться*

## Защита от регрессии производительности
Для защиты от потери достигнутого прогресса при дальнейших изменениях программы *о performance-тестах, которые вы написали*
