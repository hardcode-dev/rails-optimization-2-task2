# Case-study оптимизации

## Актуальная проблема
В нашем проекте возникла серьёзная проблема.

Необходимо было обработать файл с данными, чуть больше ста мегабайт.

У нас уже была программа на `ruby`, которая умела делать нужную обработку.

Она успешно работала на файлах размером пару мегабайт, но для большого файла она работала слишком долго, и не было понятно, закончит ли она вообще работу за какое-то разумное время.

Я решил исправить эту проблему, оптимизировав эту программу.

## Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы я придумал использовать такую метрику: потребление памяти не больше 70Мб при обработке файла data_large.txt (134 МБ, 3250940 строк) в течение всей своей работы.

## Гарантия корректности работы оптимизированной программы
Программа поставлялась с тестом. Выполнение этого теста в фидбек-лупе позволяет не допустить изменения логики программы при оптимизации.

## Feedback-Loop
Для того, чтобы иметь возможность быстро проверять гипотезы я выстроил эффективный `feedback-loop`, который позволил мне получать обратную связь по эффективности сделанных изменений для итогого потребления памяти 42.4Мб.

## Вникаем в детали системы, чтобы найти главные точки роста
Для того, чтобы найти "точки роста" для оптимизации я воспользовался RubyProf::FlatPrinter, RubyProf::GraphHtmlPrinter, RubyProf::CallStackPrinter, MemoryProfiler, Stackprof.

Вот какие проблемы удалось найти и решить



### 1. `RubyProf::FlatPrinter (ALLOCATIONS mode)` показал, что имеется излишний `split`, который дополнительно выделяет объекты в памяти, когда этого можно избежать.
(на 10_000 строк, ибо выполнение оптимизируемого скрипта ruby task-2.rb на большем объёме выполнялось долго)
```
 %self      total      self      wait     child     calls  name      location
 27.86  146929.000 146929.000     0.000     0.000    20001   String#split
 26.71  480417.000 140881.000     0.000 339536.000    10010  *Array#each
 14.45  93120.000 76192.000     0.000 16928.000     8464   <Class::Date>#parse
  5.10  26903.000 26903.000     0.000     0.000    25366   String#encode
  4.44  23399.000 23399.000     0.000     0.000    23399   String#upcase
  3.79  32580.000 20000.000     0.000 12580.000    10000   Enumerable#all?

MEMORY USAGE: 68 MB
```
удалим лишний `split` строк:
```
fields = user.split(',')
...
fields = session.split(',')
```
и будем передовать уже ранее спарсенный из строки массив элементов (происходит при парсинге файла: `cols = line.split(',')`).

стало:
```
 %self      total      self      wait     child     calls  name                           location
 31.38  401953.000 140881.000     0.000 261072.000    10010  *Array#each
 17.48  78465.000 78465.000     0.000     0.000    10001   String#split
 16.97  93120.000 76192.000     0.000 16928.000     8464   <Class::Date>#parse

MEMORY USAGE: 70 MB
```
т.е. потребление памяти `String#split` упало на ~10%


### 2. `RubyProf::CallStackPrinter (ALLOCATIONS mode)` показал, что `Array#map` генерирует много лишних объектов.
(на 10_000)

<img width="521" alt="Снимок экрана 2021-10-23 в 15 28 00" src="https://user-images.githubusercontent.com/8101357/138659031-39ddd9d1-a3c6-4072-8cce-6158263507b0.png">

внутри блока
```
53.17% (53.17%) Object#collect_stats_from_users [7 calls, 7 total]
  ...
  28.28% (53.19%) Array#map [16896 calls, 16898 total]
    20.74% (73.36%) <Class::Date>#parse [8464 calls, 8464 total]
```

`Array#map` каждый раз создаёт большое количество лишних элементов в памяти,
а так же, парсинг даты здесь излишен, т.к. формат `2016-11-25` проще сортировать как есть, без парсинга в тип `Date`.

<img width="524" alt="Снимок экрана 2021-10-23 в 15 29 24" src="https://user-images.githubusercontent.com/8101357/138659070-666ca9b4-34d7-41d8-bd11-f46af5320753.png">
В итоге, влияние Array#map стало менее заметным:
```
38.66% (38.66%) Object#collect_stats_from_users [7 calls, 7 total]
  ...
  6.06% (15.66%) Array#map [12288 calls, 12290 total]

MEMORY USAGE: 67 MB
```


### 3. `MemoryProfiler` указывает на то, что создаётся большое количество объектов String.
(на 10_000)
```
allocated objects by class
-----------------------------------
    217943  String
```
Уменьшить потребялемую память при повторяющихся строках может помочь
```
frozen_string_literal: true
```

После добавления стало:
```
allocated objects by class
-----------------------------------
    172574  String

MEMORY USAGE: 74 MB
```


### 4. `MemoryProfiler` и `Stackprof` указывают на строки с бОльшим количеством потребляемой памяти при конкатенации массивов.
(на 10_000)
MemoryProfiler:
```
allocated objects by class
-----------------------------------
    172574  String
     56184  Array
```

это происходит в строках:
MemoryProfiler:
```
allocated memory by location
-----------------------------------
 287.27 MB  task-2.rb:61
 104.07 MB  task-2.rb:107
   9.57 MB  task-2.rb:109
   9.57 MB  task-2.rb:60
   4.34 MB  task-2.rb:59
   2.51 MB  task-2.rb:46
   2.44 MB  task-2.rb:34
   2.32 MB  task-2.rb:149
   1.72 MB  task-2.rb:44
```

Stackprof:
```
 25392    (8.5%) /  16928   (5.7%)  |    61  |     sessions = sessions + [parse_session(cols)] if cols[0] == 'session'
 3072    (1.0%) /  3072   (1.0%)  |   109  |     users_objects = users_objects + [user_object]
 4608    (1.5%) /  3072   (1.0%)  |    60  |     users = users + [parse_user(cols)] if cols[0] == 'user'

 43008   (14.5%) /  43008  (14.5%)  |    44  |     user_key = "#{user.attributes['first_name']}" + ' ' + "#{user.attributes['last_name']}"
```
Оператор `+` плодит много объектов(типа Array и String) при слиянии.
Стоит заменить на ёлочку, интерполяцию строк

стало:
```
allocated objects by class
-----------------------------------
    138782  String
     36116  Hash
     33112  Array
```
т.е. создание лишних объектов Array сократилось.
```
MEMORY USAGE: 36 MB
```


### 5. Все спарсенные элементы хранятся в памяти на протяжении всего действия скрипта. Этого можно избежать, если хранить в памяти только тот массив данных который только считывается для сохранения.
(на 10_000)
MemoryProfiler:
```
allocated memory by class
-----------------------------------
 108.27 MB  Array
   8.16 MB  Hash
   7.43 MB  String
```
Все спарсенные элементы хранятся в памяти на протяжении всего выполнения скрипта.
Это значит, что много элементов используются только один раз, а всё остальное время просто занимают память.
Как вариант, считывать только те данные, которые нужно преобразовать, и затем, сразу сгружать их в целевой файл, дабы они всё время память не занимали.
Это позволит держать в памяти только то, что используется только в этот момент.

Для реализации такой логики важно заметить, что т.к. положение ключей в json не имеет значение, а важно лишь их наличие, то данные по ключам
`totalUsers`, `uniqueBrowsersCount`, `totalSessions`, `allBrowsers`, можно перенести в конец json'а.
Более того, в связи с тем, что формирование нового файла будет происходить "на лету", можно избавиться от массивов users и sessions в скрипте.
Как бонус, это избавит от лишнего select:
```
user_sessions = sessions.select { |session| session['user_id'] == user['id'] }
```
который потребляет потребляет:
```
allocated memory by location
-----------------------------------
 ...
 104.07 MB  task-2.rb:107
```

Так же потребуется вынести отдельный счётчик по числу пользователей, числу уникальных браузеров, числу сессий, и общему составу браузеров (агрегировать с помощью set).

итого:
```
allocated memory by class
-----------------------------------
  25.90 MB  File
  10.18 MB  Hash
   7.64 MB  String
   3.96 MB  Array
 860.40 kB  Proc

MEMORY USAGE: 17 MB
```
Запустил на 100_000:
```
MEMORY USAGE: 18 MB
```
выставил 1_000_000, а затем data_large.txt.
потребление памяти не превышает 70:
```
MEMORY USAGE: 20 MB
```


### 6. Использование Oj для уменьшения потребляемой памяти при генерации json.
```
stackProf
```
 439538   (17.2%) /  439538  (17.2%)  |   136  |         File.write(report_file, report.to_json[1...-1], mode: 'a')
 77229    (3.0%) /  77229   (3.0%)  |   137  |         File.write(report_file, ',', mode: 'a') if line_no != file_lines_count-1
```
заменим на использование oj:
```
 169812    (7.7%) /  169812   (7.7%)  |   136  |         File.write(report_file, "#{ Oj.to_json(report, mode: :compat)[1...-1] }#{ ',' if line_no != file_lines_count-1 }\n", mode: 'a')
MEMORY USAGE: 18 MB
```
<img width="1468" alt="Снимок экрана 2021-10-25 в 09 56 59" src="https://user-images.githubusercontent.com/8101357/138659123-fddd30ff-57da-45e3-a4cc-bcbc12be9f04.png">



## Результаты
В результате проделанной оптимизации наконец удалось обработать файл с данными.
Удалось улучшить метрику системы с (...много, не смог дождаться выхлопа с профилировщика) до 42.4Mb

Для меня было открытием, что простой `map!` модифицировал исходный массив, и уменьшал потреб памяти.



## Защита от регрессии производительности
Для защиты от потери достигнутого прогресса при дальнейших изменениях программы *о performance-тестах, которые вы написали*
