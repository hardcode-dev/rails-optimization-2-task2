# Case-study оптимизации

## Актуальная проблема

В нашем проекте возникла серьёзная проблема.

Необходимо было обработать файл с данными, чуть больше ста мегабайт.

У нас уже была программа на `ruby`, которая умела делать нужную обработку.

Она успешно работала на файлах размером пару мегабайт, но для большого файла она работала слишком долго, и не было понятно, закончит ли она вообще работу за какое-то разумное время.

Я решил исправить эту проблему, оптимизировав эту программу.

## Формирование метрики

Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы я придумал использовать такую метрику: _тут ваша метрика_

## Гарантия корректности работы оптимизированной программы

Программа поставлялась с тестом. Выполнение этого теста в фидбек-лупе позволяет не допустить изменения логики программы при оптимизации.

## Feedback-Loop

Для того, чтобы иметь возможность быстро проверять гипотезы я выстроил эффективный `feedback-loop`, который позволил мне получать обратную связь по эффективности сделанных изменений за _время, которое у вас получилось_

Вот как я построил `feedback_loop`: _как вы построили feedback_loop_

## Вникаем в детали системы, чтобы найти главные точки роста

Для того, чтобы найти "точки роста" для оптимизации я воспользовался _инструментами, которыми вы воспользовались_

Вот какие проблемы удалось найти и решить

### Ваша находка №1

- Отчет memory_profiler показал, что следующая строка аллоцирует больше всего памяти `sessions = sessions + [parse_session(line)]`
- Заменил код на `sessions << parse_session(line)`
- Аллоцированная память методом work снизилась на 60%
- Данная стррока кода перестала быть основной точкой роста и опустилась на 10 строчку

### Ваша находка №2

- Отчеты RubyProf показали, `<Class::Date>#parse` аллоцирует 20% всех объектов
- Метод `parse` используется в строке `user.sessions.map{|s| s['date']}.map {|d| Date.parse(d)}.sort.reverse.map { |d| d.iso8601 }` и заменил на `user.sessions.map{|s| s['date']}.sort.reverse`
- Количество аллоцированых объектов уменьшилось на 30 %
- Метод `parse` перестал быть точкой роста

### Ваша находка №3

- Отчеты Stackprof показали, что метод `String#split` вызывается значительное количество раз
- Заменил методы сплит на regexp
- Общее количество Sample уменьшилось на 20%
- Метод `String#split` перестал быть точкой роста

### Ваша находка №4

- Отчет memory_profiler показал, что следующая строка аллоцирует больше всего памяти `sessions.select ...`
- Добавил предварительную аггрегацию на этапа парсинга данных и спользовал ее для получения сессий `sessions_users[user['id']]`
- Общее количество аллоцированной памяти уменьшилось в 3.5 раза
- Метод `sessions.select ...` перестал быть точкой роста

### Ваша находка №5

- Отчет memory_profiler показал, что следующая строка аллоцирует больше всего памяти `users_objects = users_objects + [user_object`
- Заменил код на `users_objects << user_object`
- Аллоцированная память методом work снизилась на 30%
- Данная стррока кода перестала быть основной точкой роста

### Ваша находка №6

- Отчет memory_profiler показал, что следующая строка аллоцирует больше всего памяти `users_objects = users_objects + [user_object]` и `users = users + [parse_user(line)]`
- Заменил код на `users_objects << user_object` и `users << parse_user(line)`
- Аллоцированная память методом work снизилась в 2 раза
- Данная стррока кода перестала быть основной точкой роста

### Ваша находка №7

- Отчет memory_profiler показал, что следующая строка аллоцирует больше всего памяти `users_objects = users_objects + [user_object]` и `users = users + [parse_user(line)]`
- Заменил код на `users_objects << user_object` и `users << parse_user(line)`
- Аллоцированная память методом work снизилась в 2 раза
- Данная стррока кода перестала быть основной точкой роста

### Ваша находка №8

- Отчет memory_profiler показал, что следующая строка аллоцирует значительное количество памяти `"#{user.attributes['first_name']}" + " " + "#{user.attributes['last_name']}"`
- Заменил код на `"#{user.attributes['first_name']} #{user.attributes['last_name']}"`
- Аллоцированная память методом work снизилась на 10 процентов
- Данная стррока кода перестала быть основной точкой роста

### Ваша находка №9

- Отчет memory_profiler показал, что происходит аллоцирование памяти при вызове `report['usersStats'][user_key].merge(block.call(user))`
- Уменьшил количество вызовов `collect_stats_from_users` объединив дополнительные аггрегации в один хеш
- Аллоцированная память методом work снизилась на 23 процента
- Данная стррока кода перестала быть основной точкой роста

### Ваша находка №10

- Отчет memory_profiler показал, что происходит аллоцирование памяти при вызове `report['usersStats'][user_key].merge(block.call(user))`
- Уменьшил количество вызовов `collect_stats_from_users` объединив дополнительные аггрегации в один хеш
- Аллоцированная память методом work снизилась на 23 процента
- Данная стррока кода перестала быть основной точкой роста

### Ваша находка №11

- Отчет memory_profiler показал, что происходит аллоцирование памяти при записи в файл из итогово результата
- Использовал `while record = f.read(256)` для чтения файла по частям и `mode: 'a'` при записи в файл
- Аллоцированная память методом work в несколько раз и стала укладываться в бюджет
- Данная стррока кода перестала быть основной точкой роста

### Ваша находка №12

- Отчет memory_profiler по CPU показал, что много времени тратится на открытие и закрытие файла
- Разделил открытие/закрытие и записть файлов
- Скорость работы программы увеличилась вдвое на полном датасете
- Данная стррока кода перестала быть основной точкой роста

## Результаты

В результате проделанной оптимизации наконец удалось обработать файл с данными.
Удалось улучшить метрику системы с _того, что у вас было в начале, до того, что получилось в конце_ и уложиться в заданный бюджет.

_Какими ещё результами можете поделиться_

## Защита от регрессии производительности

Для защиты от потери достигнутого прогресса при дальнейших изменениях программы _о performance-тестах, которые вы написали_
